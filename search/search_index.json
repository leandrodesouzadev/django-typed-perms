{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":""},{"location":"#welcome-to-django-typed-perms","title":"Welcome to django-typed-perms","text":"<p>This project was built to simplify and enhance your DX (Developer Experience) using the Django Permission System. If you ever felt the Django's built-in permission checking is not very friendly, and prone to silly typing errors, then you'll like this package.</p>"},{"location":"#overview","title":"Overview","text":"<p>With this package you can check for permissions and ensure that you're using the right permission codename, without much effort. You can use <code>django-typed-perms</code> only where you find it useful. The code examples uses the models from the Django Tutorial.</p>"},{"location":"#django-default-permission-check","title":"Django default permission check","text":"<p>First, let's start on the Django default way of doing it. If you need to check for permission on a view, one way of doing it, is by doing the following:</p> polls/views.py<pre><code># Default way\nfrom django.core.exceptions import PermissionDenied\nfrom django.shortcuts import render\n\nfrom polls.models import Question\n\ndef get_polls(request):\n    if request.user is None or not request.user.has_perm(\"polls.view_question\"):\n        raise PermissionDenied\n    questions = Question.objects.all()\n</code></pre> <p>The bad thing of doing the default way, is that: * You can easily make mistake or forget how the permission codename (<code>polls.view_question</code>) is named. Is the action first, the model? And the model name can also get really unreadable if its a long name. * You don't know right away which permissions are available, for a specific model. * You must take into consideration that <code>request.user</code> may be <code>None</code>. * You don't get any auto-complete from your IDE or static checking from mypy.</p>"},{"location":"#lets-make-it-better","title":"Lets make it better","text":"<p>The only thing you need to do is add the <code>TypedPermsModelMixin</code> class to a Django Model of your choice. Since this class is a mixin, its required that you add it before the <code>models.Model</code> class.</p> polls/models.py<pre><code>from django.db import models\nfrom django_typed_perms import TypedPermsModelMixin\n\nclass Question(TypedPermsModelMixin, models.Model):\n    # fields go here...\n</code></pre> <p>That's it! You'll learn a few more tricks later on.</p> <p>This class will add some methods to your model, this methods can then be used to check permissions from your model. Let's check out how we can use these methods to enhance our permission checking.</p> polls/views.py<pre><code>from django.core.exceptions import PermissionDenied\nfrom django.shortcuts import render\n\nfrom polls.models import Question\n\ndef get_polls(request):\n    if not Question.user_has_permission(request.user, \"view\"):\n        raise PermissionDenied\n    ...\n</code></pre> <p>Notice that, you're inverting how you're essentially checking for the permission, now the permission check 'starts' from the model (<code>Question</code>), using the method <code>user_has_permission</code>. This method is defined on the <code>TypedPermsModelMixin</code> and its does exactly the same as the <code>user.has_perm</code> method, but with a few shortcuts! So what's the big deal then?</p> <ul> <li>When you're using the <code>TypedPermsModelMixin</code> way, you'll be able to view all the possible permissions for that model, with your IDE auto-complete. </li> <li>You just need to provide the \"action\" instead of the full permission codename.</li> <li>You don't need to remember the app name, neither the model name.</li> <li>You don't need to check <code>request.user</code> for a <code>None</code> value.</li> </ul> <p>And that's just the basic, check out more on the Reference section.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#installation","title":"Installation","text":"<p>This package can be installed with pip, or your package manager of preference, using:</p> <pre><code>pip install django-typed-perms\n</code></pre> <p>That's it. This project has no dependencies to other packages, and don't need any further configuration.</p>"},{"location":"ref/","title":"API Reference","text":"<p>Here you'll find all reference you need to integrate with this package. Use the left section to navigate.</p>"},{"location":"ref/TypedModelPermsMixin/generic_syntax/","title":"<code>TypedPermsModelMixin</code>","text":"<p>A mixin that can be used that adds extended functionality to a Django <code>Model</code> class. This mixin is a <code>Generic</code> type, that can take two optional arguments:</p> <ul> <li>the custom permissions; and</li> <li>the default permissions.</li> </ul> <p>These arguments when provided will provide the exact available permissions for that Model. All of the following are valid usecases:</p>"},{"location":"ref/TypedModelPermsMixin/generic_syntax/#inheriting-with-no-generic-arguments-provided","title":"Inheriting with no Generic arguments provided","text":"<p>This will cause that the Model only provide the default Django permissions, they are: <code>\"add\"</code>, <code>\"change\"</code>, <code>\"delete\"</code>, <code>\"view\"</code>. Example: polls/models.py<pre><code>from django.db import models\nfrom django_typed_perms import TypedPermsModelMixin\n\nclass Question(TypedPermsModelMixin, models.Model):\n    ...\n</code></pre></p>"},{"location":"ref/TypedModelPermsMixin/generic_syntax/#inheriting-with-a-single-generic-argument-provided","title":"Inheriting with a single <code>Generic</code> argument provided","text":"<p>This will cause that the default Django permissions to be present (listed above), plus the ones that you define.</p> polls/models.py<pre><code>from typing import Annotated, Literal\nfrom django.db import models\nfrom django_typed_perms import TypedPermsModelMixin, get_choices_from_type_hint\n\nQuestionCustomPermsT = Annotated[Literal[\"publish_question\"], \"Publish Question\"]\n\nclass Question(TypedPermsModelMixin[QuestionCustomPermsT], models.Model):\n\n    class Meta:\n        permissions = get_choices_from_type_hint(QuestionCustomPermsT)\n</code></pre> <p>Don't forget to add the <code>permissions</code> to the model's <code>Meta</code> class</p> <p>If you forget to add the <code>permissions</code> to the <code>Meta</code> class, Django won't create the corresponding <code>Permission</code> when you run <code>python manage.py makemigrations</code>. If you forget to add, checking for a permission that doesn't exist will always return a <code>False</code> value.</p> <p>What's that <code>Annotated[Literal]</code> thing that I just saw?</p> <p>Typing module <code>Annotated</code> allows you to associate any metadata you want to a specific type. In this case, the <code>Literal</code> type. With <code>Annotated</code> you can add as many metadata as you want to a type. But, in this case you're restricted just to a few, they're: <code>str</code>, a <code>None</code> value or a <code>gettext_lazy</code> call. <code>Literal</code> is a type that is saying that a value can only be that specific value.</p> <p><code>TypedPermsModelMixin</code> also allows a <code>Union</code> type of <code>Annotated</code> types. So if you have more than one custom permission, then you can use the following syntax:</p> polls/models.py<pre><code>from typing import Annotated, Literal\nfrom django.db import models\nfrom django_typed_perms import TypedPermsModelMixin, get_choices_from_type_hint\n\nQuestionCustomPermsT = (\n    Annotated[Literal[\"publish_question\"], \"Publish Question\"]\n    | Annotated[Literal[\"clear_votes\"], \"Clear Votes\"]\n)\n\nclass Question(TypedPermsModelMixin[QuestionCustomPermsT], models.Model):\n    class Meta:\n        permissions = get_choices_from_type_hint(QuestionCustomPermsT)\n</code></pre> <p>The above sintax is the equivalent of the following syntax:</p> polls/models.py<pre><code>from typing import Annotated, Literal, Union\nfrom django.db import models\nfrom django_typed_perms import TypedPermsModelMixin, get_choices_from_type_hint\n\nQuestionCustomPermsT = Union[\n    Annotated[Literal[\"publish_question\"], \"Publish Question\"],\n    Annotated[Literal[\"clear_votes\"], \"Clear Votes\"],\n]\n\nclass Question(TypedPermsModelMixin[QuestionCustomPermsT], models.Model):\n    class Meta:\n        permissions = get_choices_from_type_hint(QuestionCustomPermsT)\n</code></pre> <p>Feel free to use the syntax that you like the most.</p>"},{"location":"ref/TypedModelPermsMixin/generic_syntax/#inheriting-with-2-generic-arguments-provided","title":"Inheriting with 2 <code>Generic</code> arguments provided","text":"<p>If you need to add custom permissions and also override the default permissions, then you can use the following syntax. For example, if you only want the <code>Question</code> model to have the <code>add</code> permission, you can:</p> polls/models.py<pre><code>from typing import Annotated, Literal\nfrom django.db import models\nfrom django_typed_perms import TypedPermsModelMixin, get_choices_from_type_hint\n\nQuestionCustomPermsT = (\n    Annotated[Literal[\"publish_question\"], \"Publish Question\"]\n    | Annotated[Literal[\"clear_votes\"], \"Clear Votes\"]\n)\nQuestionDefaultPermsT = (\n    Annotated[Literal[\"add\"], \"Add Question\"]\n)\n\nclass Question(TypedPermsModelMixin[QuestionCustomPermsT, QuestionDefaultPermsT], models.Model):\n    class Meta:\n        permissions = get_choices_from_type_hint(QuestionCustomPermsT)\n        default_permissions = get_choices_from_type_hint(QuestionDefaultPermsT)\n</code></pre> <p>Now the only 3 available permissions are: <code>publish_question</code>, <code>clear_votes</code>, and <code>add</code>.</p>"},{"location":"ref/TypedModelPermsMixin/public_methods/","title":"Public methods","text":"<p>The <code>TypedPermsModelMixin</code> class adds 3 methods to the inherited class. They're described below.</p>"},{"location":"ref/TypedModelPermsMixin/public_methods/#model-definition-used-on-examples","title":"Model definition used on examples","text":"<p>All of the code examples that uses these methods assumes the following model definition: polls/models.py<pre><code>from typing import Annotated, Literal\nfrom django.db import models\nfrom django_typed_perms import TypedPermsModelMixin, get_choices_from_type_hint\n\nQuestionCustomPermsT = (\n    Annotated[Literal[\"publish_question\"], \"Publish Question\"]\n    | Annotated[Literal[\"clear_votes\"], \"Clear Votes\"]\n)\n\nclass Question(TypedPermsModelMixin[QuestionCustomPermsT], models.Model):\n    class Meta:\n        permissions = get_choices_from_type_hint(QuestionCustomPermsT)\n</code></pre></p>"},{"location":"ref/TypedModelPermsMixin/public_methods/#user_has_permission","title":"<code>user_has_permission</code>","text":"<p>This method is used to check a given <code>user</code> has the permission to do some <code>action</code> on that specific <code>Model</code> class or object. You can use this method as a type-safe replacement for <code>user.has_perm</code> method from <code>django.contrib.auth.models.AbstractUser</code>. The key difference, is that since you'll be using a specific class to check permissions for, then you only be able to check for an <code>action</code> of that specific class.</p> <p>Imagine the following permission check, we want to check if the user has permission to <code>view</code> the <code>Question</code> objects. This is a default permission of any Django model. So, using the <code>user.has_perm</code> method, you would do the following:</p> polls/views.py<pre><code>def get_polls(request):\n    if not request.user or not request.user.has_perm(\"polls.view_question\"):\n        # Raise an error, missing permissions\n        ...\n</code></pre> <p>If you have ever done a Django project before, you recognize this pattern. And you know this can get really annoying, if you do some easy mistakes, like:</p> <ul> <li>Don't checking for a <code>None</code> value on <code>request.user</code> (Some <code>AuthenticationBackend</code> could've assigned <code>None</code> as value), and that would result on a <code>TypeError</code>.</li> <li>Mispelling the permission <code>codename</code> (that is <code>{app_name}.{action}_{model_name}</code>) on entirety, or any of its pieces. This would result on a possible false positive.</li> <li>This is repetitive, and not developer-friendly.</li> </ul> <p>Now, let's do the same permission check using the <code>user_has_permission</code> method.</p> polls/views.py<pre><code>from polls.models import Question\n\ndef get_polls(request):\n    if not Question.user_has_permission(request.user, \"view\"):\n        # Raise an error, missing permissions\n        ...\n</code></pre> <p>The same result, but way less things to type, and to make a mistake. When using this method, you don't have to: * Worry about checking <code>request.user</code> for a <code>None</code> value; * Worry about mispelling the exact permission <code>codename</code>, or the <code>app_name</code>, or the <code>action</code> name, or the <code>model_name</code>. If you're using <code>mypy</code> you'll get an error if you provide a invalid <code>action</code>.</p>"},{"location":"ref/TypedModelPermsMixin/public_methods/#method-signature","title":"method signature","text":"<p>This method requires 2 positional/keyword arguments, they are: * <code>user</code>: An <code>user-like</code> object or <code>None</code>. Meaning that this object must have the <code>has_perm</code> method. * <code>action</code>: The name of the action to check permission against. This is either one of the Django's default permission, such as <code>add</code>, <code>change</code>, <code>delete</code>, or <code>view</code>.</p> <p>It also optionally accepts a 3rd argument, the <code>obj</code> to check the permission against, we don't do anything with this argument, its directly passed to the <code>user.has_perm</code> method.</p>"},{"location":"ref/TypedModelPermsMixin/public_methods/#user_has_permissions","title":"<code>user_has_permissions</code>","text":"<p>This method is essentially the same as the method, above, the only difference is that instead of calling <code>user.has_perm</code>, it calls <code>user.has_perms</code> with the provided <code>Sequence</code> of <code>actions</code> provided (such as <code>tuple</code> or a <code>list</code>).</p> polls/views.py<pre><code>def get_polls(request):\n    if not Question.user_has_permissions(request.user, (\"view\", \"add\")):\n        # Raise an error, missing permissions\n        ...\n</code></pre>"},{"location":"ref/TypedModelPermsMixin/public_methods/#get_action_permission_name","title":"<code>get_action_permission_name</code>","text":"<p>This method can be used to retrieve the full qualified name of a permission, that can be used on <code>user.has_perm</code> call, for example. It accepts a single argument: <code>action</code> that is one of the Django's default permissions or any of the custom permissions provided on the mixin. This method is used internally by the methods <code>user_has_permission</code> and <code>user_has_permissions</code> to build the full permission name. Example:</p> polls/views.py<pre><code>def get_polls(request):\n    if not request.user not request.user.has_perm(Question.get_action_permission_name(\"view\")):\n        # Raise an error, missing permissions\n        ...\n</code></pre> <p>This is the exact same of typing the full permission <code>codename</code>, such as:</p> polls/views.py<pre><code>def get_polls(request):\n    if not request.user not request.user.has_perm(\"polls.view_question\"):\n        # Raise an error, missing permissions\n        ...\n</code></pre>"}]}